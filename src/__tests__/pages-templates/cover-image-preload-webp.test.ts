// Tests for cover image WebP optimization in TutorialsDetailPage and PostsDetailPage
// Verifies that getImage() is used to generate a WebP URL at build time for
// preload hints and OG meta tags, instead of the raw JPG from coverImage.src.
//
// Context: coverImage is ImageMetadata from src/assets/ — its .src property
// points to the original JPG, not the /_astro/*.webp generated by Astro's
// image pipeline. Using getImage() ensures the preload and OG image are WebP.

import fs from "fs";
import path from "path";

import { describe, expect, it } from "vitest";

const TEMPLATES = [
  {
    name: "TutorialsDetailPage",
    path: path.resolve(__dirname, "../../pages-templates/tutorials/TutorialsDetailPage.astro"),
    coverVar: "coverImage",
    optimizedVar: "optimizedCoverImage",
  },
  {
    name: "PostsDetailPage",
    path: path.resolve(__dirname, "../../pages-templates/posts/PostsDetailPage.astro"),
    coverVar: "coverImage",
    optimizedVar: "optimizedCoverImage",
  },
];

for (const template of TEMPLATES) {
  describe(`${template.name} — cover image WebP for preload and OG meta`, () => {
    let content: string;

    it("template file should exist", () => {
      expect(fs.existsSync(template.path)).toBe(true);
      content = fs.readFileSync(template.path, "utf-8");
    });

    it("should import getImage from astro:assets", () => {
      content = fs.readFileSync(template.path, "utf-8");

      expect(content).toMatch(/import\s*\{[^}]*getImage[^}]*\}\s*from\s*["']astro:assets["']/);
    });

    it("should call getImage() with the cover image to produce a WebP URL", () => {
      content = fs.readFileSync(template.path, "utf-8");

      // Must await getImage with src: coverImage and format: 'webp'
      expect(content).toMatch(
        new RegExp(
          `getImage\\s*\\(\\s*\\{[^}]*src:\\s*${template.coverVar}[^}]*format:\\s*["']webp["'][^}]*\\}\\s*\\)`,
        ),
      );
    });

    it("should use optimized WebP URL for preloadImage prop", () => {
      content = fs.readFileSync(template.path, "utf-8");

      // preload hint must point to the WebP, not the original JPG
      expect(content).toMatch(new RegExp(`preloadImage=\\{${template.optimizedVar}\\.src\\}`));
    });

    it("should use optimized WebP URL for Layout image prop (OG/Twitter)", () => {
      content = fs.readFileSync(template.path, "utf-8");

      // og:image must serve WebP
      expect(content).toMatch(new RegExp(`image=\\{${template.optimizedVar}\\.src\\}`));
    });

    it("should use optimized WebP URL for JSON-LD schema image field", () => {
      content = fs.readFileSync(template.path, "utf-8");

      // JSON-LD schema.org image field
      expect(content).toMatch(new RegExp(`image:\\s*${template.optimizedVar}\\.src`));
    });

    it("should NOT use raw coverImage.src for preloadImage", () => {
      content = fs.readFileSync(template.path, "utf-8");

      expect(content).not.toMatch(new RegExp(`preloadImage=\\{${template.coverVar}\\.src\\}`));
    });

    it("should NOT use raw coverImage.src for Layout image prop", () => {
      content = fs.readFileSync(template.path, "utf-8");

      expect(content).not.toMatch(new RegExp(`image=\\{${template.coverVar}\\.src\\}`));
    });
  });
}
