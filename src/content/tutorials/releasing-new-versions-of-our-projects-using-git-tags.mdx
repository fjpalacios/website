---
title: "Releasing new versions of our projects using Git tags"
post_slug: "releasing-new-versions-of-our-projects-using-git-tags"
date: "2018-01-11"
excerpt: "Discover how to use Git tags to version your code. Learn how to create, list, and delete annotated and lightweight tags."
language: "en"
categories: ["git"]
course: "mastering-git-from-scratch"
order: 13
cover: "/images/tutorials/cabecera-git.jpg"
i18n: "lanzando-versiones-tags-git"
---

import { InlineImage } from "@components/blog";

We're learning a lot of new things to master Git, but until now we haven't said anything about the versions of our projects. We know that you are very advanced in your project and thanks to Git you are working in a more efficient way. You are about to publish the version 0.1 of your project, so people can try it and leave their opinions, butâ€¦ How the heck we create a new version of our software in Git? Let's go to it!

In Git there is a function to add _tags_ to our _commits_, which are only a few pointers (like **HEAD** or each of the branches, as we saw before), this allows us to reference a _commit_ that we want to be able to locate and access it easily. We can actually create _tags_ for any _commit_ we want to locate quickly once time has passed, but it's true that this function is generally used to launch versions of our applications.

FYI: There are two types of _tags_, _annotated_ and _lightweight tags_.

### Lightweight tags

First we will focus on the _lightweight tags_, which are the easiest to learn. This type of _tags_ is usually used to locate a specially relevant _commit_ but not a release of a new version. Why? Because you can only add a label with a name and this doesn't seem very useful, isn't it? It's a kind of reminder, usually a temporary one.

If you want to add the _tag_ to the most recent _commit_ just run the `git tag v0.1` command, and if we use the `git log --oneline --decorate` command we'll see that now our **HEAD** also has the **tag: v0.1** pointer; if we want to add a _tag_ to a previous _commit_ you can also do it, either through the hash of the _commit_ (the _code_ that references the _commit_ located first in the `log` command) or, as we've learned to do, referencing it in a relative way from the most recent _commit_ (_HEAD_), like: `git tag v0.1 HEAD~2`.

### Annotated tags

In simple words, an _annotated tag_ is something like a _commit_ as it's treated as an object by Git; in this type of _tags_ we can add a message that explain the reason for having added that _tag_, in addition, the date it was added and who added it will be saved; that's why it's great for our code versioning, since more information is stored and in the message we can write what are the changes that this new version adds.

The command is very similar to the one we have already learned, but adding some parameters. If we want to write a short message, we can do it as in _commits_: `git tag -a v0.1 -m "Testing Git tags"` but if you want to write a longer message, which is recommended, just write `git tag -a v0.1` so that Git opens us the text editor that we've configured previously to write everything we want. Logically we can also add _annotated tags_ for previous _commits_: `git tag -a v0.1 -m "Testing Git tags" HEAD~2` easy peasy, right?

### Listing tags

We can also get a list of all added _tags_, and the easiest way is through the `git tag` command. So easy for you guys, huh? Well, what if you already have a mature development and you have many added versions? Holy shit! That list would be very long! But fortunately there's a way to filter the results. If we want to filter the added _tags_ of the 0.\* versions we could execute the `git tag -l "v0.*"` command.

### Getting more information about a tag

If we've added an _annotated tag_, with the `git show v0.1` command we can see all the information related to the _tag_ but also with the _commit_ to which it refers; if we've added a _lightweight tag_, then we'll only get information about the _commit_ to which it refers because from the _tag_ there would be no information to obtain.

### Removing tags

At any time we can delete a tag, whether it's an _annotated tag_ or not, with the same command: `git tag -d v0.1`. This command doesn't need more explanation, isn't it?

### Sending a tag to a remote node

If you want to send a certain _tag_ to a remote node (if you do not know what a remote is, take a look at [Creating our first repository on GitHub](/en/article/creating-our-first-repository-on-github/)) you can do it in the same way as we'd send a new branch: `git push origin v0.1` and if you want to send more than one _tag_ you can execute the command `git push origin --tags` to send them all with a single command.

### Working with tags on remote nodes

When sending _tags_ to remote nodes like [GitHub](https://github.com/) or [GitLab](https://gitlab.com/) we offer users who visit our projects the information that a new version was released but also that they can download it easily, and for convenience it's created automatically. In GitHub, for example, when a new _tag_ is sent, it obviously appears in the section of _tags_, but also in the _releases_ one, therefore create a new version of our application so that users can download it is a quick and easy task.

<InlineImage type="tutorial" src="/images/tutorials/inline/seccion-tags-github.jpeg" alt="Tags section on GitHub" />

Now you can no longer say that you've not shared with the world a version of your application (I hope an open source application) because you didn't know how to do it.

Never stop programming!
