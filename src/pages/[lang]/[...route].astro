---
/**
 * Unified Dynamic Routing - All Content Types & Taxonomies (Phase 6 Refactored)
 *
 * Configuration-driven router that eliminates repetitive code patterns.
 *
 * Handles all main content type pages:
 * - Books: /en/books, /es/libros (list, pagination, detail)
 * - Tutorials: /en/tutorials, /es/tutoriales (list, pagination, detail)
 * - Posts: /en/posts, /es/publicaciones (list, pagination, detail - mixed content)
 * - Taxonomies: Authors, Publishers, Genres, Categories, Series, Challenges, Courses
 * - Static: About, Feeds
 *
 * This replaces 52 duplicate page files with 1 unified router + 25 templates.
 *
 * Phase 4 Optimization: Extracted route generation logic to utilities
 * Phase 5.2 Optimization: Added caching and parallel generation for performance
 * Phase 6 Optimization: Config-driven approach + dynamic template mapping
 *
 * @see src/utils/routeGenerators/
 * @see src/utils/cache/
 * @see src/config/templateMap.ts
 * @see src/config/routeConfig.ts
 */

import type { GetStaticPaths } from "astro";

// Configuration
import { CONTENT_TYPE_CONFIGS, TAXONOMY_TYPES } from "@/config/routeConfig";
import { getRouteSegment } from "@/config/routeSegments";
import { getTemplate } from "@/config/templateMap";
// Contact data
import contactEn from "@/content/static/contact/en.json";
import contactEs from "@/content/static/contact/es.json";
// Utilities
import { paginateItems, getPageCount } from "@/utils/blog";
import { logCacheStats } from "@/utils/cache/buildCache";
import { getCachedCollection } from "@/utils/cache/cachedLoaders";
import { performanceMonitor } from "@/utils/performance/monitor";
import { getAllContentForLanguage, POSTS_PER_PAGE, generatePostDetailPaths } from "@/utils/postsPages";
import {
  generateContentTypeWithPaginationRoutes,
  generateTaxonomyRoutes,
  generateStaticPageRoute,
} from "@/utils/routeGenerators";
import { getLanguages } from "@/utils/routes";
import { generateItemListSchema } from "@/utils/schemas/itemList";
import { TAXONOMY_CONFIGS } from "@/utils/taxonomyPages";

/**
 * Generates all static paths for the unified dynamic router
 *
 * This function is the heart of the routing system. It generates all page paths
 * for both languages (ES/EN) including:
 * - Content with pagination (Books, Tutorials, Posts)
 * - Taxonomies (Authors, Publishers, Genres, etc.)
 * - Static pages (About, Feeds)
 *
 * Performance optimizations:
 * - Parallel generation of independent content types
 * - Build-time caching to avoid duplicate queries
 * - Performance monitoring to track generation time
 * - Configuration-driven approach eliminates code duplication
 *
 * @returns Array of static paths with params and props for each page
 */
export const getStaticPaths: GetStaticPaths = async () => {
  performanceMonitor.start("total-route-generation");

  const languages = getLanguages();
  const paths: { params: { lang: string; route: string }; props: Record<string, unknown> }[] = [];

  /**
   * Helper function to safely generate routes with error handling
   * @param generator Function that generates routes
   * @param context Description of what's being generated (for error messages)
   * @returns Array of generated paths, or empty array if generation fails
   */
  const safeGenerateRoutes = async (
    generator: () => Promise<Array<{ params: { lang: string; route: string }; props: Record<string, unknown> }>>,
    context: string,
  ): Promise<Array<{ params: { lang: string; route: string }; props: Record<string, unknown> }>> => {
    try {
      return await generator();
    } catch (error) {
      console.error(`[Unified Routing] Error generating routes for ${context}:`, error);
      // Return empty array to allow build to continue with other routes
      // This prevents a single content type error from breaking the entire build
      return [];
    }
  };

  /**
   * Maps content type to Schema.org type and route segment
   * Used for mixed content (posts that can be BlogPosting, TechArticle, or Book)
   */
  const CONTENT_TYPE_MAPPING = {
    book: {
      schemaType: "Book" as const,
      routeKey: "books" as const,
    },
    tutorial: {
      schemaType: "TechArticle" as const,
      routeKey: "tutorials" as const,
    },
    post: {
      schemaType: "BlogPosting" as const,
      routeKey: "posts" as const,
    },
  } as const;

  /**
   * Get content type mapping for schema generation
   * @param contentType The content type from post data
   * @returns Schema type and route key for the content
   */
  const getContentTypeMapping = (contentType: string) => {
    return CONTENT_TYPE_MAPPING[contentType as keyof typeof CONTENT_TYPE_MAPPING] || CONTENT_TYPE_MAPPING.post;
  };

  // =================================================================
  // LANGUAGE-SPECIFIC ROUTE GENERATION
  // =================================================================
  // Process each language independently (ES and EN)
  // Each iteration generates all routes for one language

  for (const lang of languages) {
    performanceMonitor.start(`routes-${lang}`);

    // Load contact data for current language
    const contact = lang === "en" ? contactEn : contactEs;
    // Determine target language for translation availability checks
    const targetLang = lang === "en" ? "es" : "en";

    // =================================================================
    // PARALLEL ROUTE GENERATION - Phase 5.2 Optimization
    // =================================================================
    // Generate independent content types in parallel for better performance
    // Books, Tutorials, and Taxonomies can be generated simultaneously

    performanceMonitor.start(`parallel-generation-${lang}`);

    // Build parallel generators for all content types
    const parallelGenerators = [
      // Generate routes for all configured content types (books, tutorials)
      ...Object.values(CONTENT_TYPE_CONFIGS).map((config) =>
        safeGenerateRoutes(
          async () =>
            generateContentTypeWithPaginationRoutes({
              lang,
              targetLang,
              routeSegment: getRouteSegment(config.routeKey, lang),
              pageSegment: getRouteSegment("page", lang),
              contentType: config.contentType,
              getAllItems: config.getAllItems,
              itemsPerPage: config.itemsPerPage,
              generateDetailPaths: config.generateDetailPaths,
              contact,
              schemaType: config.schemaType,
              extractItemData: config.extractItemData,
            }),
          `${config.contentType} (${lang})`,
        ),
      ),

      // Generate routes for all taxonomies
      ...TAXONOMY_TYPES.map((taxonomyType) =>
        safeGenerateRoutes(
          async () =>
            generateTaxonomyRoutes({
              taxonomyConfig: TAXONOMY_CONFIGS[taxonomyType],
              lang,
              targetLang,
              routeSegment: getRouteSegment(taxonomyType, lang),
              contentType: taxonomyType,
              contact,
              itemsPropsKey: `${taxonomyType}WithCounts` as const,
            }),
          `${taxonomyType} (${lang})`,
        ),
      ),
    ];

    // Execute all generators in parallel
    const allRoutes = await Promise.all(parallelGenerators);
    performanceMonitor.end(`parallel-generation-${lang}`);

    // Flatten and add all generated routes
    paths.push(...allRoutes.flat());

    // =================================================================
    // POSTS - Special case (mixed content: posts + tutorials + books)
    // Cannot use generic generator due to complex schema mapping
    // =================================================================
    performanceMonitor.start(`posts-${lang}`);
    try {
      const routeSegment = getRouteSegment("posts", lang);
      const pageSegment = getRouteSegment("page", lang);

      // âš¡ Performance: Fetch both languages in parallel using cached loaders
      const [sortedContent, targetContent] = await Promise.all([
        getCachedCollection("posts", lang, getAllContentForLanguage),
        getCachedCollection("posts", targetLang, getAllContentForLanguage),
      ]);

      const hasTargetContent = targetContent.length > 0;
      const totalPages = getPageCount(sortedContent.length, POSTS_PER_PAGE);

      // 1. LIST PAGE
      const posts = paginateItems(sortedContent, 1, POSTS_PER_PAGE);

      // Generate ItemList schema for mixed content
      const itemListSchema = generateItemListSchema(
        posts.map((post) => {
          // Use mapping helper to get schema type and route key
          const { schemaType, routeKey } = getContentTypeMapping(post.type);
          const localizedRouteSegment = getRouteSegment(routeKey, lang);

          return {
            name: post.title,
            url: `/${lang}/${localizedRouteSegment}/${post.slug}/`,
            type: schemaType,
            description: post.excerpt,
          };
        }),
        "https://fjp.es",
      );

      paths.push({
        params: { lang, route: routeSegment },
        props: {
          contentType: "posts",
          pageType: "list",
          lang,
          posts,
          currentPage: 1,
          totalPages,
          itemListSchema,
          contact,
          hasTargetContent,
        },
      });

      // 2. PAGINATION PAGES
      for (let page = 2; page <= totalPages; page++) {
        const paginatedPosts = paginateItems(sortedContent, page, POSTS_PER_PAGE);

        paths.push({
          params: { lang, route: `${routeSegment}/${pageSegment}/${page}` },
          props: {
            contentType: "posts",
            pageType: "pagination",
            lang,
            posts: paginatedPosts,
            currentPage: page,
            totalPages,
            contact,
            hasTargetContent,
          },
        });
      }

      // 3. DETAIL PAGES (only for "posts" collection, not books/tutorials)
      const postDetailPaths = await generatePostDetailPaths(lang, contact);
      for (const { slug, props } of postDetailPaths) {
        paths.push({
          params: { lang, route: `${routeSegment}/${slug}` },
          props: {
            contentType: "posts",
            pageType: "detail",
            ...props,
            hasTargetContent,
          },
        });
      }
    } catch (error) {
      console.error(`[Unified Routing] Error generating routes for posts (${lang}):`, error);
    }
    performanceMonitor.end(`posts-${lang}`);

    // =================================================================
    // STATIC PAGES - About and Feeds
    // =================================================================
    performanceMonitor.start(`static-${lang}`);

    // ABOUT PAGE
    try {
      const aboutContent =
        lang === "en"
          ? await import("@content/en/about.ts").then((mod) => mod.about)
          : await import("@content/es/about.ts").then((mod) => mod.about);

      paths.push(
        ...generateStaticPageRoute({
          lang,
          routeSegment: getRouteSegment("about", lang),
          contentType: "about",
          contact,
          content: aboutContent,
        }),
      );
    } catch (error) {
      console.error(`[Unified Routing] Error generating routes for about (${lang}):`, error);
    }

    // FEEDS PAGE
    try {
      paths.push(
        ...generateStaticPageRoute({
          lang,
          routeSegment: getRouteSegment("feeds", lang),
          contentType: "feeds",
          contact,
        }),
      );
    } catch (error) {
      console.error(`[Unified Routing] Error generating routes for feeds (${lang}):`, error);
    }

    performanceMonitor.end(`static-${lang}`);
    performanceMonitor.end(`routes-${lang}`);
  }

  performanceMonitor.end("total-route-generation");

  console.log(`[Unified Routing] Generated ${paths.length} paths (all content types + taxonomies + static pages)`);

  // Log performance and cache statistics
  performanceMonitor.printSummary();
  logCacheStats();

  return paths;
};

// =================================================================
// DYNAMIC TEMPLATE SELECTION
// =================================================================
// Use template map to select the correct component based on contentType + pageType
// This replaces 47 lines of conditional rendering with a single lookup

const { pageType, contentType } = Astro.props;

// Get the appropriate template component
const Template = getTemplate(contentType, pageType);
---

{
  Template ? (
    <Template {...Astro.props} />
  ) : (
    <div>
      <h1>404 - Template Not Found</h1>
      <p>
        No template found for contentType="{contentType}" and pageType="{pageType}"
      </p>
    </div>
  )
}
